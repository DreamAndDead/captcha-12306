# captcha 12306

识别 12306 验证码

## run

example


## dataset

数据集使用 20200214 日的验证码，网络爬取 1w 张

每张验证码中包含1个文本图片，8个物体图片，总体来看，数据集包含

1w 张文本(text)图片
8w 张实物(image)图片

### clip

在验证码中

文本所占的区域是固定的，x > 120, y < 28

但是对于大部分空白地方，可以进一步分析从而去除，使截取的文本图片尽量只包含文本
这样，文本图片就没有得到统一的 shape 了



图片的位置是固定的，依次截取 8 张




### label

#### text

文本图片相对实物图片而言比较简单，形状大小比较小（平均 50x30 的样子），且色彩单一，纯黑白

目前得到的是没有标注的数据集，这里借助 baidu ocr api 先进行初步的识别

对 ocr 识别的结果，做文本标注的个数统计，从大到小排列，观察结果

```
result
```

如果相信 ocr 的识别性能（人工检测后也的确如此），则可以相信，正确识别的文本标注个数应该大于错误识别的标注
比如 `日历 > E历`，`菠萝 > 波萝`

从排列的结果中我们可以观察出，有意义的标注大约有 80+ 个，准确来说应该是 80 个
对于非 80 个结果中的标注，都是错误的识别

这样来看，10000 图片中大约有 6000 正确分类，其余 4000 识别不正确，正确率大概 60%
因为这里的 ocr 接口是一个通用接口，过程大概是先从图片中切块为单字，再对单字进行识别，最后组成词
由于我们在这里知道了所有数据的分类数量，在这样一个限定的范围内进行分类，自然要比广泛的分类得到的结果要好


对于剩下的 4000 张图，要一张一张进行人工分类，可不是简单的工作

一个思路是，使用 kmeans 算法将 4000 张图片进行自聚类，分为 80 个类。
虽然结果并不一定完全准确，但是每个类中就包含了大多数相似的文本，这时再进行人工标注可能会简单一些。


#### image

这里可以和文本标注一样，先调用 baidu 识图接口进行一个粗略的分类，剩下的聚类进而人工识别。

首先，识图接口有数量限制，500 per day
而且，由于识图也是一个通用接口，会得到五花八门的结果，不一定落在 80 个类中，同一个物体，可能有不同层次的描述
比如 `动物->老虎->华南虎`


在另一个项目中，得到一个非常不错的想法，使用统计学的方法

在已知文本识别结果正确率已经很高的情况下，一张验证码中的 8 张图片，是文本标注分类的可能性为 1/8，
而是其它标注的可能性为 1/80，这时我们可以大胆的对这 8 张图片进行标注，标注为文本表示的标注

这样得到的最终标注后的数据集，每个分类中大约只有 1/8 的图片是正确的标注，其它都是错误标注
进一步的，平均情况下，每个验证码中会有 2 个文本标注的物体，这时每个分类中大约有 1/4 的图片是正确的


如果用这个数据集来训练网络，进而识别图片物体，由于每次选择最大概率的结果作为最终结果，即使数据集标注的并非完全正确，
依然可以得到一个不错的结果。

可以这样理解，如果完全标注正确，则是 1/1 和 1/80 的差距
现在的错误标注，使用的是 1/8 和 1/80 的差距，进行训练

直到进行 predict 的时候，1/8 的概率会高于 1/80，偏向于使用最大概率结果


原项目中有一个悖论，只能识别 1/8 的正确率，但是如果验证集没有使用同样 1/8 标注的图片，而是使用了正确标注的图片，这就是一个悖论
既然已经有了正确标注的图片，直接用它们来训练和分类不就完了吗？
所以使用正确标注的图片，只能作为方法的检测，而不能证明方法是完全不信赖外部而自动化的。


所以如果在错误标注的数据集上进行验证，准确率应该在 25% 左右。


### train


#### text

在文本图片完全标注的情况下，共 1w 张，一共 80 个类，每个类约 125 张，感觉量不是很充足

因为图片文本确实比较简单，颜色有限，而且变形幅度不大，使用 LeNet 来训练完全没有问题

在数据集中训练验证，正确率达到95%


#### image

根据上面的图片标注方法，在图片完全标注后，
有 8w 张图片，80 个类，每个类约 1000 张图片


使用 LeNet VGG 应该足够验证






## env

```
keras==2.3.1
tensorflow-gpu=2.1.0
opencv-contrib-python==3.4.2.17
numpy==1.18.2
imutils==0.5.3
scikit-learn==0.22.2
matplotlib==3.2.1
```
